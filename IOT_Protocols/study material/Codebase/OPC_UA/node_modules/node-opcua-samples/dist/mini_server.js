"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-console
const chalk = require("chalk");
const path = require("path");
const os = require("os");
const node_opcua_1 = require("node-opcua");
Error.stackTraceLimit = Infinity;
const port = 26544;
const envPaths = require("env-paths");
const config = envPaths("MiniNodeOPCUA-Server").config;
const pkiFolder = path.join(config, "PKI");
const serverOptions = {
    serverCertificateManager: new node_opcua_1.OPCUACertificateManager({
        rootFolder: pkiFolder
    }),
    port,
    maxAllowedSessionNumber: 2,
    maxConnectionsPerEndpoint: 2,
    nodeset_filename: [(0, node_opcua_1.get_mini_nodeset_filename)()],
    serverInfo: {
        applicationUri: (0, node_opcua_1.makeApplicationUrn)(os.hostname(), "MiniNodeOPCUA-Server"),
        productUri: "Mini NodeOPCUA-Server",
        applicationName: { text: "Mini NodeOPCUA Server", locale: "en" },
        gatewayServerUri: null,
        discoveryProfileUri: null,
        discoveryUrls: []
    },
    buildInfo: {
        buildNumber: "1234"
    },
    serverCapabilities: {
        maxBrowseContinuationPoints: 10,
        maxHistoryContinuationPoints: 10,
        // maxInactiveLockTime
        operationLimits: {
            maxNodesPerBrowse: 10,
            maxNodesPerHistoryReadData: 6,
            maxNodesPerHistoryReadEvents: 10,
            maxNodesPerHistoryUpdateData: 10,
            maxNodesPerRead: 10,
            maxNodesPerWrite: 10
        }
    },
    isAuditing: false
};
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        process.title = "Node OPCUA Server on port : " + serverOptions.port;
        const server = new node_opcua_1.OPCUAServer(serverOptions);
        console.log(chalk.yellow("  server PID          :"), process.pid);
        try {
            yield server.start();
        }
        catch (err) {
            console.log(" Server failed to start ... exiting");
            process.exit(-3);
        }
        const endpointUrl = server.getEndpointUrl();
        console.log(chalk.yellow("  server on port      :"), server.endpoints[0].port.toString());
        console.log(chalk.yellow("  endpointUrl         :"), chalk.cyan(endpointUrl));
        console.log(chalk.yellow("\n  server now waiting for connections. CTRL+C to stop"));
        server.on("create_session", (session) => {
            console.log(" SESSION CREATED");
            console.log(chalk.cyan("    client application URI: "), session.clientDescription.applicationUri);
            console.log(chalk.cyan("        client product URI: "), session.clientDescription.productUri);
            console.log(chalk.cyan("   client application name: "), session.clientDescription.applicationName.toString());
            console.log(chalk.cyan("   client application type: "), session.clientDescription.applicationType.toString());
            console.log(chalk.cyan("              session name: "), session.sessionName ? session.sessionName.toString() : "<null>");
            console.log(chalk.cyan("           session timeout: "), session.sessionTimeout);
            console.log(chalk.cyan("                session id: "), session.nodeId);
        });
        server.on("session_closed", (session, reason) => {
            console.log(" SESSION CLOSED :", reason);
            console.log(chalk.cyan("              session name: "), session.sessionName ? session.sessionName.toString() : "<null>");
        });
    });
}
main();
//# sourceMappingURL=mini_server.js.map