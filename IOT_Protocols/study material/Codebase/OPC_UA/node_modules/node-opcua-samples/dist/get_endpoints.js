#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-console
const chalk = require("chalk");
const fs = require("fs");
const path = require("path");
const yargs = require("yargs");
const node_opcua_1 = require("node-opcua");
const node_opcua_crypto_1 = require("node-opcua-crypto");
// tslint:disable:no-var-requires
const Table = require("easy-table");
const treeify = require("treeify");
// eslint-disable-next-line max-statements
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        // ts-node bin/simple_client.ts --endpoint  opc.tcp://localhost:53530/OPCUA/SimulationServer --node "ns=5;s=Sinusoid1"
        const argv = yield yargs(process.argv)
            .wrap(132)
            .option("endpoint", {
            alias: "e",
            demandOption: true,
            describe: "the end point to connect to "
        })
            .option("securityMode", {
            alias: "s",
            default: "None",
            describe: "the security mode (  None Sign SignAndEncrypt )"
        })
            .option("securityPolicy", {
            alias: "P",
            default: "None",
            describe: "the policy mode : (" + Object.keys(node_opcua_1.SecurityPolicy).join(" - ") + ")"
        })
            .option("discovery", {
            alias: "D",
            describe: "specify the endpoint uri of discovery server (by default same as server endpoint uri)"
        })
            .example("get_endpoints  --endpoint opc.tcp://localhost:49230", "").argv;
        const securityMode = (0, node_opcua_1.coerceMessageSecurityMode)(argv.securityMode);
        if (securityMode === node_opcua_1.MessageSecurityMode.Invalid) {
            throw new Error("Invalid Security mode");
        }
        const securityPolicy = (0, node_opcua_1.coerceSecurityPolicy)(argv.securityPolicy);
        if (securityPolicy === node_opcua_1.SecurityPolicy.Invalid) {
            throw new Error("Invalid securityPolicy");
        }
        console.log(chalk.cyan("securityMode        = "), securityMode.toString());
        console.log(chalk.cyan("securityPolicy      = "), securityPolicy.toString());
        const endpointUrl = argv.endpoint;
        if (!endpointUrl) {
            yargs.showHelp();
            process.exit(0);
        }
        const discoveryUrl = argv.discovery ? argv.discovery : endpointUrl;
        const optionsInitial = {
            securityMode,
            securityPolicy,
            endpointMustExist: false,
            connectionStrategy: {
                initialDelay: 2000,
                maxDelay: 10 * 1000,
                maxRetry: 10
            },
            discoveryUrl
        };
        const client = node_opcua_1.OPCUAClient.create(optionsInitial);
        client.on("backoff", (retry, delay) => {
            console.log(chalk.bgWhite.yellow("backoff  attempt #"), retry, " retrying in ", delay / 1000.0, " seconds");
        });
        console.log(" connecting to ", chalk.cyan.bold(endpointUrl));
        console.log("    strategy", client.connectionStrategy);
        try {
            yield client.connect(endpointUrl);
        }
        catch (err) {
            console.log(chalk.red(" Cannot connect to ") + endpointUrl);
            if (err instanceof Error) {
                console.log(" Error = ", err.message);
            }
            return;
        }
        const endpoints = yield client.getEndpoints();
        if (argv.debug) {
            fs.writeFileSync("tmp/endpoints.log", JSON.stringify(endpoints, null, " "));
            console.log(treeify.asTree(endpoints, true));
        }
        const table = new Table();
        let serverCertificate;
        let i = 0;
        for (const endpoint of endpoints) {
            table.cell("endpoint", endpoint.endpointUrl + "");
            table.cell("Application URI", endpoint.server.applicationUri);
            table.cell("Product URI", endpoint.server.productUri);
            table.cell("Application Name", endpoint.server.applicationName.text);
            table.cell("securityLevel", endpoint.securityLevel);
            table.cell("Security Mode", chalk.cyan(node_opcua_1.MessageSecurityMode[endpoint.securityMode].toString()));
            table.cell("securityPolicyUri", chalk.cyan(endpoint.securityPolicyUri));
            table.cell("Type", node_opcua_1.ApplicationType[endpoint.server.applicationType]);
            table.cell("certificate", "..." /*endpoint.serverCertificate*/);
            endpoint.server.discoveryUrls = endpoint.server.discoveryUrls || [];
            table.cell("discoveryUrls", endpoint.server.discoveryUrls.join(" - "));
            serverCertificate = endpoint.serverCertificate;
            const certificate_filename = path.join(__dirname, "../certificates/PKI/server_certificate" + i + ".pem");
            if (serverCertificate) {
                fs.writeFile(certificate_filename, (0, node_opcua_crypto_1.toPem)(serverCertificate, "CERTIFICATE"), () => {
                    /**/
                });
            }
            table.newRow();
            i++;
        }
        console.log(table.toString());
        for (const endpoint of endpoints) {
            console.log("Identify Token for : Security Mode=", chalk.cyan(node_opcua_1.MessageSecurityMode[endpoint.securityMode].toString()), " Policy=", chalk.cyan(endpoint.securityPolicyUri));
            const table2 = new Table();
            for (const token of endpoint.userIdentityTokens) {
                table2.cell("policyId", token.policyId);
                table2.cell("tokenType", node_opcua_1.UserTokenType[token.tokenType]);
                table2.cell("issuedTokenType", token.issuedTokenType);
                table2.cell("issuerEndpointUrl", token.issuerEndpointUrl);
                table2.cell("securityPolicyUri", token.securityPolicyUri);
                table2.newRow();
            }
            console.log(table2.toString());
        }
        yield client.disconnect();
        console.log("success !!   ");
        process.exit(0);
    });
}
main();
//# sourceMappingURL=get_endpoints.js.map